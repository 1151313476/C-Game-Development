# 闪屏问题

现象：使用清空绘图函数时，会产生绘图区域闪动问题；

原因：在本次清空后，下次绘图前，会有一段时间的黑屏;

解决方式：**双缓冲机制**

```c++
绘图流程：
[应用程序] -> [绘制命令] -> [后端缓冲区] 
-> [完成一帧] -> [缓冲区交换] -> [前端缓冲区显示]
```



```c++
int main() {
    initgraph(1280, 720);

    BeginBatchDraw();      // 开始批量绘图
    
    while (true) {
        // 处理消息
        
        // 绘图逻辑
        cleardevice();
        solidcircle(300, 300, 100);
        
        FlushBatchDraw();  // 批量绘制
    }
    
    EndBatchDraw();
    closegraph();
    return 0;
}
```



# CPU占用高的问题

现象：程序运行时CPU使用率异常偏高（可能达到90%-100%）

原因：：图形程序的主循环在没有适当延迟的情况下全速运行

解决方式：动态延迟优化

```c++
const int TARGET_FPS = 60; // 目标帧率
const double FRAME_TIME = 1000.0 / TARGET_FPS; // 每帧时间(ms)

int main() {
	//...
    
    while (true) {
        auto start = std::chrono::steady_clock::now();
        
		//...
        // 动态延迟计算
        auto end = std::chrono::steady_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
        if (elapsed < FRAME_TIME) {
            Sleep(FRAME_TIME - elapsed); // 保持固定帧率
        }
    }
	//...
}
```





# 移动抽搐问题、连续移动顿挫问题

现象：玩家移动时先向移动方向抽搐下再移动、移动过程中有明显的顿挫感

1、移动抽搐问题

原因：键盘按键消息的底层机制：**首次按下** → 触发 `WM_KEYDOWN`。**短暂延迟后** → 系统才持续发送 `WM_KEYDOWN`（自动重复）。

2、移动过程中有明显的顿挫感

原因：消息队列输入（消息的产生），与游戏主循环是异步进行的，且产生频率与硬件和操作系统相关；导致输入响应不均匀，进而在有些游戏帧中，玩家移动的较远或较近

解决方式：只检测玩家的按下和送开输入、移动的连续性由 **`isMovingLeft`/`isMovingRight` 状态** 控制，而非消息队列频率。



# 玩家斜向速度快问题

现象：当玩家同时按住 **两个方向键**（如 ↑ + →）时，移动速度比单一方向快约 **1.414 倍**（即 √2）。
原因：斜向移动时，系统会 **叠加两个方向的位移**，实际移动距离 = √(speed² + speed²) = **speed × √2**，导致速度异常。

解决方式：**向量归一化**







