# 羊了个羊数据流分析

## 1. 游戏管理器初始化数据流
**调用者**: GameManager.onLoad (GameManager.ts)

GameManager.onLoad触发 -> 预加载场景 -> 注册事件监听 -> 
{
    事件注册成功且场景预加载完成? -> 是 -> 调用gameStart -> 返回true
    事件注册失败或场景预加载失败? -> 否 -> 显示错误 -> 返回false
} 

## 3. 游戏开始数据流
**调用者**: GameManager.gameStart (GameManager.ts)

gameStart调用 -> 读取游戏数据 -> 初始化关卡 -> 
{
    数据读取成功且关卡配置有效? -> 是 -> 调用initGame -> 返回true
    数据读取失败或关卡配置无效? -> 否 -> 重置到第一关 -> 返回false
} 

## 4. 关卡初始化数据流
**调用者**: GameManager.initGame (GameManager.ts)

initGame调用 -> 获取关卡配置 -> 计算总块数 -> 
{
    关卡配置存在且计算有效? -> 是 -> 生成方块数组 -> 分配区域 -> 返回true
    关卡配置不存在或计算无效? -> 否 -> 使用默认配置 -> 返回false
} 

## 5. 方块创建数据流
**调用者**: GameManager.initGame (GameManager.ts)

方块创建调用 -> 实例化预制体 -> 初始化方块数据 -> 
{
    预制体存在且数据有效? -> 是 -> 设置方块属性 -> 添加到场景 -> 返回true
    预制体不存在或数据无效? -> 否 -> 跳过创建 -> 返回false
} 

## 7. 方块点击响应数据流
**调用者**: Block.onTouchStart (Block.ts)

onTouchStart触发 -> 检查游戏状态 -> 检查方块可点击性 -> 
{
    游戏运行中且方块可点击? -> 是 -> 播放音效 -> 调用toSlot -> 返回true
    游戏未运行或方块不可点击? -> 否 -> 立即返回false
} 

## 8. 方块移动到槽位数据流
**调用者**: Block.toSlot (Block.ts)

toSlot调用 -> 更新层级关系 -> 记录操作历史 -> 
{
    槽位未满且操作有效? -> 是 -> 移动方块到槽位 -> 重新排序 -> 触发CHECK_CLEAR -> 返回true
    槽位已满或操作无效? -> 否 -> 立即返回false
}

## 9. 消除检查数据流
**调用者**: Block.toSlot (Block.ts)

CHECK_CLEAR事件触发 -> 获取槽位方块 -> 按类型分组 -> 
{
    存在3个相同类型方块? -> 是 -> 执行消除动画 -> 播放消除音效 -> 返回true
    不存在3个相同类型方块? -> 否 -> 立即返回false
} 



## 11. 扩展技能数据流
**调用者**: 按钮

onGameExtend调用 -> 获取槽位方块 -> 检查扩展区容量 -> 
{
    槽位有方块且扩展区未满? -> 是 -> 移动方块到扩展区 -> 更新渲染 -> 返回true
    槽位无方块或扩展区已满? -> 否 -> 立即返回false
} -> 
GameManager根据返回值处理（移动成功则更新位置，失败则保持原位）

## 12. 撤销技能数据流
**调用者**: 按钮

OnGameUndo调用 -> 检查操作记录栈 -> 弹出最后操作 -> 
{
    记录栈非空且有操作记录? -> 是 -> 恢复方块状态 -> 更新层级关系 -> 返回true
    记录栈为空或无操作记录? -> 否 -> 立即返回false
} -> 
GameManager根据返回值处理（撤销成功则更新状态，失败则忽略）

## 13. 洗牌技能数据流
**调用者**:按钮

OnGameshuffle调用 -> 获取主游戏区方块 -> 打乱方块类型 -> 
{
    主游戏区有方块且可洗牌? -> 是 -> 重新分配类型 -> 更新渲染 -> 返回true
    主游戏区无方块或不可洗牌? -> 否 -> 立即返回false
} -> 
GameManager根据返回值处理（洗牌成功则更新显示，失败则保持原状）

## 14. 方块状态变化数据流
**调用者**: Block.boardType setter (Block.ts)

boardType变化 -> 触发CHANGE_BOARD事件 -> GameManager.onBoardChange接收 -> 
{
    方块移动有效且状态更新成功? -> 是 -> 更新游戏状态 -> 检查游戏结束 -> 返回true
    方块移动无效或状态更新失败? -> 否 -> 回滚状态 -> 返回false
} -> 
GameManager根据返回值处理（成功则继续游戏，失败则回滚操作）

## 15. 游戏失败检查数据流
**调用者**: GameManager.onBoardChange (GameManager.ts)

onBoardChange触发 -> 检查剩余方块 -> 检查可点击方块 -> 
{
    存在可点击方块且槽位未满? -> 是 -> 继续游戏 -> 返回false
    无可点击方块或槽位已满? -> 否 -> 游戏失败 -> 返回true
} -> 
GameManager根据返回值处理（继续则保持运行，失败则显示失败界面）

## 16. 游戏胜利检查数据流
**调用者**: GameManager.onClearCheck (GameManager.ts)

onClearCheck触发 -> 检查剩余方块数量 -> 验证游戏状态 -> 
{
    所有方块已消除且游戏正常? -> 是 -> 显示胜利界面 -> 播放胜利音效 -> 返回true
    仍有方块未消除或游戏异常? -> 否 -> 继续游戏 -> 返回false
} -> 
GameManager根据返回值处理（完成则显示胜利，未完成则继续游戏）

## 17. 音频播放数据流
**调用者**: 各组件的事件触发

PLAY_AUDIO事件触发 -> MusicManager.onAudioPlay接收 -> 获取音频类型 -> 
{
    音频资源存在且可播放? -> 是 -> 播放音效 -> 更新音频状态 -> 返回true
    音频资源不存在或不可播放? -> 否 -> 立即返回false
} -> 
MusicManager根据返回值处理（播放成功则继续，失败则忽略）

## 18. 特效播放数据流
**调用者**: Block.onTouchStart (Block.ts)

PLAY_BROKEN事件触发 -> BrokenManager.onBrokenBuild接收 -> 获取方块位置 -> 
{
    特效预制体存在且位置有效? -> 是 -> 生成碎片 -> 应用物理力 -> 返回true
    特效预制体不存在或位置无效? -> 否 -> 立即返回false
} -> 
BrokenManager根据返回值处理（特效成功则播放动画，失败则忽略）

## 19. 数据持久化数据流
**调用者**: DataManager.level setter (DataManager.ts)

level属性变化 -> 触发save调用 -> 序列化游戏数据 -> 
{
    数据有效且localStorage可用? -> 是 -> 保存到localStorage -> 更新存储状态 -> 返回true
    数据无效或localStorage不可用? -> 否 -> 立即返回false
} -> 
DataManager根据返回值处理（保存成功则继续，失败则显示错误）

